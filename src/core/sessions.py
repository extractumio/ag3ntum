"""
Session directory management for Ag3ntum.

Handles session directory creation and workspace setup.
Each session has an isolated workspace with:
- agent.jsonl - Claude SDK event log
- workspace/ - Agent working directory with external mounts

NOTE: All session metadata is stored in SQLite database (Session model),
NOT in files. This module only manages directory structure.
"""
import logging
import shutil
import uuid
from datetime import datetime
from pathlib import Path

from .exceptions import SessionError

logger = logging.getLogger(__name__)


class SessionManager:
    """
    Manages session directories and file paths.

    NOTE: Session metadata (status, cumulative stats, etc.) is stored in
    the SQLite database, NOT in files. This class only handles:
    - Directory structure creation
    - File path resolution
    - External mount symlinks
    - Workspace cleanup

    The session directory contains:
    - agent.jsonl - SDK event log (required by Claude SDK)
    - workspace/ - Agent working directory
    """

    def __init__(self, sessions_dir: Path) -> None:
        """
        Initialize the session manager.

        Args:
            sessions_dir: Directory to store sessions.
        """
        self._sessions_dir = sessions_dir
        # Note: Directory is created on-demand in create_session_directory(), not here.
        # This allows lazy initialization for per-user session directories.

    def create_session_directory(
        self,
        session_id: str | None = None
    ) -> str:
        """
        Create the directory structure for a new session.

        Args:
            session_id: Optional session ID. If None, generates one.

        Returns:
            The session ID (generated or provided).
        """
        if session_id is None:
            session_id = generate_session_id()

        session_dir = self.get_session_dir(session_id)
        session_dir.mkdir(parents=True, exist_ok=True)

        # Create workspace subdirectory
        workspace = session_dir / "workspace"
        workspace.mkdir(exist_ok=True)

        logger.info(f"Created session directory: {session_id}")
        return session_id

    def get_session_dir(self, session_id: str) -> Path:
        """
        Get the directory for a session.

        Args:
            session_id: The session ID.

        Returns:
            Path to the session directory.
        """
        return self._sessions_dir / session_id

    def get_log_file(self, session_id: str) -> Path:
        """
        Get the log file path for a session.

        Args:
            session_id: The session ID.

        Returns:
            Path to the agent.jsonl file.
        """
        return self.get_session_dir(session_id) / "agent.jsonl"

    def get_workspace_dir(self, session_id: str) -> Path:
        """
        Get the workspace directory for a session.

        The workspace is a sandboxed subdirectory where the agent can
        write output. This is separate from the session directory to
        prevent the agent from reading logs and other sensitive files.

        Args:
            session_id: The session ID.

        Returns:
            Path to the workspace directory.
        """
        workspace = self.get_session_dir(session_id) / "workspace"
        workspace.mkdir(parents=True, exist_ok=True)
        return workspace

    def setup_external_mounts(self, session_id: str, username: str) -> None:
        """
        Create symlinks for external mounts in the workspace.

        Creates the ./external/ directory structure with symlinks to:
        - ./external/ro/{name} -> /mounts/ro/{name} (global read-only mounts)
        - ./external/rw/{name} -> /mounts/rw/{name} (global read-write mounts)
        - ./external/user-ro/{name} -> {host_path} (per-user read-only mounts)
        - ./external/user-rw/{name} -> {host_path} (per-user read-write mounts)
        - ./external/persistent -> /users/{username}/ag3ntum/persistent

        This allows both the File Browser UI and agent tools to see the same files.

        Args:
            session_id: The session ID.
            username: The username for persistent storage path and per-user mounts.
        """
        import yaml

        workspace = self.get_workspace_dir(session_id)
        external_dir = workspace / "external"

        # Create base directories
        (external_dir / "ro").mkdir(parents=True, exist_ok=True)
        (external_dir / "rw").mkdir(parents=True, exist_ok=True)
        (external_dir / "user-ro").mkdir(parents=True, exist_ok=True)
        (external_dir / "user-rw").mkdir(parents=True, exist_ok=True)

        # Load global mounts configuration from auto-generated-mounts.yaml (generated by run.sh)
        mounts_file = Path("/data/auto-generated/auto-generated-mounts.yaml")

        if mounts_file.exists():
            try:
                with open(mounts_file, "r", encoding="utf-8") as f:
                    manifest = yaml.safe_load(f) or {}

                mounts_data = manifest.get("mounts", {})

                # Create RO mount symlinks
                if isinstance(mounts_data.get("ro"), list):
                    for mount in mounts_data["ro"]:
                        if isinstance(mount, dict) and mount.get("name"):
                            name = mount["name"]
                            link = external_dir / "ro" / name
                            target = Path(f"/mounts/ro/{name}")

                            # Skip if mount doesn't exist in Docker
                            if not target.exists():
                                logger.debug(f"Skipping RO mount '{name}': {target} does not exist")
                                continue

                            # Skip if symlink already exists and is valid
                            if link.is_symlink() and link.exists():
                                continue

                            # Remove broken symlink if present
                            if link.is_symlink():
                                try:
                                    link.unlink()
                                except OSError as e:
                                    logger.warning(f"Failed to remove broken RO symlink {name}: {e}")
                                    continue

                            # Skip if regular file/directory exists
                            if link.exists():
                                continue

                            try:
                                link.symlink_to(target)
                                logger.debug(f"Created RO mount symlink: {link} -> {target}")
                            except OSError as e:
                                logger.warning(f"Failed to create RO symlink for {name}: {e}")

                # Create RW mount symlinks
                if isinstance(mounts_data.get("rw"), list):
                    for mount in mounts_data["rw"]:
                        if isinstance(mount, dict) and mount.get("name"):
                            name = mount["name"]
                            link = external_dir / "rw" / name
                            target = Path(f"/mounts/rw/{name}")

                            # Skip if mount doesn't exist in Docker
                            if not target.exists():
                                logger.debug(f"Skipping RW mount '{name}': {target} does not exist")
                                continue

                            # Skip if symlink already exists and is valid
                            if link.is_symlink() and link.exists():
                                continue

                            # Remove broken symlink if present
                            if link.is_symlink():
                                try:
                                    link.unlink()
                                except OSError as e:
                                    logger.warning(f"Failed to remove broken RW symlink {name}: {e}")
                                    continue

                            # Skip if regular file/directory exists
                            if link.exists():
                                continue

                            try:
                                link.symlink_to(target)
                                logger.debug(f"Created RW mount symlink: {link} -> {target}")
                            except OSError as e:
                                logger.warning(f"Failed to create RW symlink for {name}: {e}")

            except Exception as e:
                logger.warning(f"Failed to load mounts config: {e}")

        # Load per-user mounts from external-mounts.yaml
        from ..services.mount_service import get_user_mounts

        try:
            user_mounts = get_user_mounts(username)

            # Create per-user RO mount symlinks
            # Per-user mounts are mounted at /mounts/user-ro/{name} inside Docker
            for mount_info in user_mounts.get("ro", []):
                name = mount_info["name"]
                link = external_dir / "user-ro" / name
                target = Path(f"/mounts/user-ro/{name}")

                # Skip if mount doesn't exist and is required
                if not target.exists():
                    is_optional = mount_info.get("optional", True)
                    if not is_optional:
                        logger.warning(f"Required per-user RO mount missing: {target}")
                    continue

                if not link.exists() and not link.is_symlink():
                    try:
                        link.symlink_to(target)
                        logger.debug(f"Created user RO mount symlink: {link} -> {target}")
                    except OSError as e:
                        logger.warning(f"Failed to create user RO symlink for {name}: {e}")

            # Create per-user RW mount symlinks
            for mount_info in user_mounts.get("rw", []):
                name = mount_info["name"]
                link = external_dir / "user-rw" / name
                target = Path(f"/mounts/user-rw/{name}")

                # Skip if mount doesn't exist and is required
                if not target.exists():
                    is_optional = mount_info.get("optional", True)
                    if not is_optional:
                        logger.warning(f"Required per-user RW mount missing: {target}")
                    continue

                if not link.exists() and not link.is_symlink():
                    try:
                        link.symlink_to(target)
                        logger.debug(f"Created user RW mount symlink: {link} -> {target}")
                    except OSError as e:
                        logger.warning(f"Failed to create user RW symlink for {name}: {e}")

        except Exception as e:
            logger.warning(f"Failed to load per-user mounts: {e}")

        # Create persistent storage symlink
        # The persistent directory is at {user_home}/ag3ntum/persistent
        # where user_home is derived from the sessions directory (sessions_dir.parent)
        # This is created during user registration, but we ensure it exists here too
        persistent_link = external_dir / "persistent"
        user_home = self._sessions_dir.parent  # e.g., /users/{username}/sessions -> /users/{username}
        persistent_dir = user_home / "ag3ntum" / "persistent"

        # Ensure the persistent directory exists
        # FAIL FAST: If we can't create it, the session should fail - not silently skip
        if not persistent_dir.exists():
            try:
                persistent_dir.mkdir(parents=True, exist_ok=True)
                logger.info(f"Created persistent storage directory: {persistent_dir}")
            except OSError as e:
                raise SessionError(
                    f"Failed to create persistent storage directory {persistent_dir}: {e}. "
                    "This directory is required for bwrap sandbox mounts."
                )

        # Create or fix the symlink
        try:
            if persistent_link.is_symlink():
                if not persistent_link.exists():
                    # Broken symlink - remove and recreate
                    persistent_link.unlink()
                    persistent_link.symlink_to(persistent_dir)
                    logger.debug(f"Fixed broken persistent symlink: {persistent_link}")
                # else: symlink exists and is valid, nothing to do
            elif not persistent_link.exists():
                # No symlink - create it
                persistent_link.symlink_to(persistent_dir)
                logger.debug(f"Created persistent symlink: {persistent_link} -> {persistent_dir}")
        except OSError as e:
            raise SessionError(
                f"Failed to create persistent storage symlink: {e}"
            )

        logger.info(f"Set up external mounts for session {session_id}")

    def cleanup_workspace_skills(self, session_id: str) -> None:
        """
        Remove the skills folder from a session's workspace.

        Called after agent run completes to clean up merged skills symlinks.
        The .claude/skills/ directory contains symlinks to actual skill sources.
        Workspace files are preserved.

        Args:
            session_id: The session ID.
        """
        # New structure: .claude/skills/ contains symlinks
        claude_skills_dir = (
            self.get_session_dir(session_id) / "workspace" / ".claude" / "skills"
        )

        if claude_skills_dir.exists():
            try:
                # Remove the directory with all its symlinks
                shutil.rmtree(claude_skills_dir)
                logger.info(
                    f"Cleaned up workspace/.claude/skills/ for session {session_id}"
                )
            except Exception as e:
                logger.warning(
                    f"Failed to cleanup workspace skills for session {session_id}: {e}"
                )

        # Also clean old-style skills/ symlink for backward compatibility
        old_skills_link = self.get_session_dir(session_id) / "workspace" / "skills"
        if old_skills_link.is_symlink():
            try:
                old_skills_link.unlink()
                logger.debug(f"Removed legacy skills symlink for session {session_id}")
            except Exception as e:
                logger.warning(f"Failed to remove legacy skills symlink: {e}")

    def session_dir_exists(self, session_id: str) -> bool:
        """
        Check if a session directory exists.

        Args:
            session_id: The session ID.

        Returns:
            True if the session directory exists, False otherwise.
        """
        return self.get_session_dir(session_id).exists()


def generate_session_id() -> str:
    """Generate a unique session ID."""
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    uid = uuid.uuid4().hex[:8]
    return f"{ts}_{uid}"
